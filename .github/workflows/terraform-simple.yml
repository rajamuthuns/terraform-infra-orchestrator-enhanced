name: Terraform Deploy

on:
  push:
    branches:
      - dev
      - staging
      - production
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment test'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - production
      action:
        description: 'Pipeline action'
        required: true
        default: 'plan-and-apply'
        type: choice
        options:
          - setup-only
          - plan-only
          - plan-and-apply
          - destroy
      skip_setup:
        description: 'Skip setup stage (if backends already exist)'
        required: false
        default: false
        type: boolean
      create_promotion_pr:
        description: 'Create PR to next environment after successful deployment'
        required: false
        default: true
        type: boolean

env:
  TF_VERSION: "1.6.0"
  AWS_DEFAULT_REGION: "us-east-1"

jobs:
  setup-backends:
    name: Setup Terraform Backends
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.skip_setup != 'true') ||
      (github.event_name == 'push')
    outputs:
      setup-success: ${{ steps.setup-result.outputs.success }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Configure Git Authentication
        run: |
          git config --global url."https://${{ secrets.PRIVATE_REPO_TOKEN }}@github.com/".insteadOf "https://github.com/"
          git config --global credential.helper store
          git config --global user.email "github-actions@github.com"
          git config --global user.name "GitHub Actions"
          
          mkdir -p ~/.git
          echo "https://${{ secrets.PRIVATE_REPO_TOKEN }}@github.com" > ~/.git-credentials
          chmod 600 ~/.git-credentials
          
          echo "GIT_CONFIG_GLOBAL=$HOME/.gitconfig" >> $GITHUB_ENV
          echo "GIT_ASKPASS=echo" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Determine target environment
        id: target-env
        run: |
          echo "ðŸ”§ Setup Backend Job Started"
          echo "ðŸ“‹ Event: ${{ github.event_name }}"
          echo "ðŸ“‹ Action: ${{ github.event.inputs.action }}"
          echo "ðŸ“‹ Skip Setup: ${{ github.event.inputs.skip_setup }}"
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            case "${{ github.ref_name }}" in
              "dev") ENV="dev" ;;
              "staging") ENV="staging" ;;
              "production") ENV="production" ;;
              *) ENV="dev" ;;
            esac
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "âœ… Target environment: $ENV"

      - name: Setup backend configurations
        run: |
          TARGET_ENV="${{ steps.target-env.outputs.environment }}"
          
          echo "ðŸ”§ Starting backend setup for environment: $TARGET_ENV"
          echo "ðŸ“‹ Event: ${{ github.event_name }}"
          echo "ðŸ“‹ Action: ${{ github.event.inputs.action }}"
          
          TARGET_ACCOUNT_ID=$(jq -r ".${TARGET_ENV}.account_id" config/aws-accounts.json)
          if [ "$TARGET_ACCOUNT_ID" = "null" ] || [ -z "$TARGET_ACCOUNT_ID" ]; then
            echo "âŒ Error: Account ID not found for environment $TARGET_ENV"
            echo "Available accounts:"
            cat config/aws-accounts.json
            exit 1
          fi
          
          echo "âœ… Setting up backend for environment: $TARGET_ENV (Account: $TARGET_ACCOUNT_ID)"
          
          # Assume OrganizationAccountAccessRole for the target account
          ROLE_ARN="arn:aws:iam::${TARGET_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
          
          echo "Assuming role: $ROLE_ARN"
          CREDENTIALS=$(aws sts assume-role \
            --role-arn "$ROLE_ARN" \
            --role-session-name "backend-setup-${TARGET_ENV}" \
            --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
            --output text)
          
          export AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | cut -d' ' -f1)
          export AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | cut -d' ' -f2)
          export AWS_SESSION_TOKEN=$(echo $CREDENTIALS | cut -d' ' -f3)
          
          # Backend resource names
          BUCKET_NAME="terraform-state-${TARGET_ENV}-${TARGET_ACCOUNT_ID}"
          DYNAMODB_TABLE="terraform-state-locks-${TARGET_ENV}"
          
          # Create S3 bucket
          echo "Creating S3 bucket: $BUCKET_NAME"
          if aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
            echo "Bucket $BUCKET_NAME already exists, skipping creation"
          else
            aws s3api create-bucket --bucket "$BUCKET_NAME" --region us-east-1
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" --server-side-encryption-configuration '{
              "Rules": [{
                "ApplyServerSideEncryptionByDefault": {
                  "SSEAlgorithm": "AES256"
                }
              }]
            }'
            aws s3api put-public-access-block --bucket "$BUCKET_NAME" --public-access-block-configuration \
              "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
          fi
          
          # Create DynamoDB table
          echo "Creating DynamoDB table: $DYNAMODB_TABLE"
          if aws dynamodb describe-table --table-name "$DYNAMODB_TABLE" 2>/dev/null; then
            echo "Table $DYNAMODB_TABLE already exists, skipping creation"
          else
            aws dynamodb create-table \
              --table-name "$DYNAMODB_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST \
              --sse-specification Enabled=true
          fi
          
          # Update backend configuration file
          echo "bucket         = \"${BUCKET_NAME}\"" > "shared/backend-${TARGET_ENV}.hcl"
          echo "key            = \"environments/${TARGET_ENV}/terraform.tfstate\"" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "region         = \"us-east-1\"" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "dynamodb_table = \"${DYNAMODB_TABLE}\"" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "encrypt        = true" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "workspace_key_prefix = \"env\"" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "skip_credentials_validation = false" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "skip_metadata_api_check = false" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "skip_region_validation = false" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "use_path_style = false" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "" >> "shared/backend-${TARGET_ENV}.hcl"
          echo "max_retries = 5" >> "shared/backend-${TARGET_ENV}.hcl"
          
          echo "âœ… Backend setup completed for $TARGET_ENV"
          echo "ðŸ“¦ Bucket: $BUCKET_NAME"
          echo "ðŸ—„ï¸ DynamoDB: $DYNAMODB_TABLE"
          echo "ðŸ“„ Backend file updated:"
          cat "shared/backend-${TARGET_ENV}.hcl"

      - name: Upload backend artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-backends
          path: shared/backend-*.hcl
          retention-days: 7

      - name: Set setup success output
        id: setup-result
        run: echo "success=true" >> $GITHUB_OUTPUT

  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      tfvars-file: ${{ steps.env.outputs.tfvars-file }}
      needs-approval: ${{ steps.env.outputs.needs-approval }}
    steps:
      - name: Determine environment from branch or input
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            case "${{ github.ref_name }}" in
              "dev") ENV="dev" ;;
              "staging") ENV="staging" ;;
              "production") ENV="production" ;;
              *) ENV="dev" ;;
            esac
          fi
          
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          
          case "$ENV" in
            "dev")
              echo "tfvars-file=dev-terraform.tfvars" >> $GITHUB_OUTPUT
              echo "needs-approval=false" >> $GITHUB_OUTPUT
              ;;
            "staging")
              echo "tfvars-file=stg-terraform.tfvars" >> $GITHUB_OUTPUT
              echo "needs-approval=true" >> $GITHUB_OUTPUT
              ;;
            "production")
              echo "tfvars-file=prod-terraform.tfvars" >> $GITHUB_OUTPUT
              echo "needs-approval=true" >> $GITHUB_OUTPUT
              ;;
          esac
          
          echo "Determined environment: $ENV"

  terraform-plan:
    name: Terraform Plan - ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [setup-backends, determine-environment]
    if: |
      always() && 
      (
        (github.event_name == 'workflow_dispatch' && (github.event.inputs.action == 'plan-and-apply' || github.event.inputs.action == 'plan-only')) ||
        (github.event_name == 'push')
      ) &&
      (
        (needs.setup-backends.result == 'success') ||
        (needs.setup-backends.result == 'skipped')
      )
    outputs:
      plan-success: ${{ steps.plan-result.outputs.success }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Configure Git Authentication
        run: |
          git config --global url."https://${{ secrets.PRIVATE_REPO_TOKEN }}@github.com/".insteadOf "https://github.com/"
          git config --global credential.helper store
          git config --global user.email "github-actions@github.com"
          git config --global user.name "GitHub Actions"
          
          mkdir -p ~/.git
          echo "https://${{ secrets.PRIVATE_REPO_TOKEN }}@github.com" > ~/.git-credentials
          chmod 600 ~/.git-credentials
          
          echo "GIT_CONFIG_GLOBAL=$HOME/.gitconfig" >> $GITHUB_ENV
          echo "GIT_ASKPASS=echo" >> $GITHUB_ENV

      - name: Download backend artifacts
        if: needs.setup-backends.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: terraform-backends
          path: shared/
        continue-on-error: true

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Assume target account role
        run: |
          TARGET_ACCOUNT_ID=$(jq -r ".${{ needs.determine-environment.outputs.environment }}.account_id" config/aws-accounts.json)
          if [ "$TARGET_ACCOUNT_ID" = "null" ] || [ -z "$TARGET_ACCOUNT_ID" ]; then
            echo "Error: Account ID not found for environment ${{ needs.determine-environment.outputs.environment }}"
            exit 1
          fi
          
          TARGET_ROLE_ARN="arn:aws:iam::${TARGET_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
          
          TARGET_CREDENTIALS=$(aws sts assume-role \
            --role-arn $TARGET_ROLE_ARN \
            --role-session-name github-actions-${{ needs.determine-environment.outputs.environment }}-${{ github.run_id }} \
            --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
            --output text)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $TARGET_CREDENTIALS | cut -d' ' -f1)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $TARGET_CREDENTIALS | cut -d' ' -f2)" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $TARGET_CREDENTIALS | cut -d' ' -f3)" >> $GITHUB_ENV

      - name: Check backend configuration
        run: |
          BACKEND_FILE="shared/backend-${{ needs.determine-environment.outputs.environment }}.hcl"
          if [ ! -f "$BACKEND_FILE" ]; then
            echo "âŒ Backend configuration file not found: $BACKEND_FILE"
            echo "This usually means the setup stage was skipped or failed."
            echo "Available backend files:"
            ls -la shared/backend-*.hcl 2>/dev/null || echo "No backend files found"
            exit 1
          fi
          
          if grep -q "REPLACE_WITH_ACTUAL" "$BACKEND_FILE"; then
            echo "âŒ Backend configuration contains placeholder values"
            echo "Content of $BACKEND_FILE:"
            cat "$BACKEND_FILE"
            echo "The setup stage needs to run first to replace these placeholders."
            exit 1
          fi
          
          echo "âœ… Backend configuration looks good:"
          cat "$BACKEND_FILE"

      - name: Terraform Init
        run: |
          terraform init -backend-config=shared/backend-${{ needs.determine-environment.outputs.environment }}.hcl
        env:
          GITHUB_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}
          GIT_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Terraform Workspace
        run: |
          terraform workspace select ${{ needs.determine-environment.outputs.environment }} || terraform workspace new ${{ needs.determine-environment.outputs.environment }}

      - name: Terraform Plan
        id: plan
        run: |
          if [ ! -f tfvars/${{ needs.determine-environment.outputs.tfvars-file }} ]; then
            echo "Error: tfvars file not found: tfvars/${{ needs.determine-environment.outputs.tfvars-file }}"
            exit 1
          fi
          
          terraform plan -var-file=tfvars/${{ needs.determine-environment.outputs.tfvars-file }} -out=tfplan
          
          terraform show -no-color tfplan > plan-output.txt
          echo "## Terraform Plan Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tfvars File:** ${{ needs.determine-environment.outputs.tfvars-file }}" >> $GITHUB_STEP_SUMMARY

      - name: Upload plan artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ needs.determine-environment.outputs.environment }}
          path: |
            tfplan
            plan-output.txt
          retention-days: 7

      - name: Set plan success output
        id: plan-result
        run: echo "success=true" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy - ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [setup-backends, determine-environment, terraform-plan]
    if: |
      always() && 
      needs.terraform-plan.outputs.plan-success == 'true' &&
      (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan-and-apply') ||
        (github.event_name == 'push')
      ) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'plan-only')
    environment: 
      name: ${{ needs.determine-environment.outputs.environment }}
    outputs:
      deploy-success: ${{ steps.apply-result.outputs.success }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Configure Git Authentication
        run: |
          git config --global url."https://${{ secrets.PRIVATE_REPO_TOKEN }}@github.com/".insteadOf "https://github.com/"
          git config --global credential.helper store
          git config --global user.email "github-actions@github.com"
          git config --global user.name "GitHub Actions"
          
          mkdir -p ~/.git
          echo "https://${{ secrets.PRIVATE_REPO_TOKEN }}@github.com" > ~/.git-credentials
          chmod 600 ~/.git-credentials
          
          echo "GIT_CONFIG_GLOBAL=$HOME/.gitconfig" >> $GITHUB_ENV
          echo "GIT_ASKPASS=echo" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Download backend artifacts
        if: needs.setup-backends.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: terraform-backends
          path: shared/
        continue-on-error: true

      - name: Download plan artifacts
        uses: actions/download-artifact@v4
        with:
          name: tfplan-${{ needs.determine-environment.outputs.environment }}
          path: ./

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Assume target account role
        run: |
          TARGET_ACCOUNT_ID=$(jq -r ".${{ needs.determine-environment.outputs.environment }}.account_id" config/aws-accounts.json)
          TARGET_ROLE_ARN="arn:aws:iam::${TARGET_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
          
          TARGET_CREDENTIALS=$(aws sts assume-role \
            --role-arn $TARGET_ROLE_ARN \
            --role-session-name github-actions-apply-${{ needs.determine-environment.outputs.environment }}-${{ github.run_id }} \
            --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
            --output text)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $TARGET_CREDENTIALS | cut -d' ' -f1)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $TARGET_CREDENTIALS | cut -d' ' -f2)" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $TARGET_CREDENTIALS | cut -d' ' -f3)" >> $GITHUB_ENV

      - name: Check backend configuration
        run: |
          BACKEND_FILE="shared/backend-${{ needs.determine-environment.outputs.environment }}.hcl"
          if [ ! -f "$BACKEND_FILE" ]; then
            echo "âŒ Backend configuration file not found: $BACKEND_FILE"
            echo "Available backend files:"
            ls -la shared/backend-*.hcl 2>/dev/null || echo "No backend files found"
            exit 1
          fi
          
          if grep -q "REPLACE_WITH_ACTUAL" "$BACKEND_FILE"; then
            echo "âŒ Backend configuration contains placeholder values"
            echo "Content of $BACKEND_FILE:"
            cat "$BACKEND_FILE"
            echo "The setup stage needs to run first to replace these placeholders."
            exit 1
          fi
          
          echo "âœ… Backend configuration looks good:"
          cat "$BACKEND_FILE"

      - name: Terraform Init
        run: |
          terraform init -backend-config=shared/backend-${{ needs.determine-environment.outputs.environment }}.hcl
        env:
          GITHUB_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}
          GIT_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Terraform Workspace
        run: |
          terraform workspace select ${{ needs.determine-environment.outputs.environment }}

      - name: Terraform Apply
        id: apply
        run: |
          if [ -f tfplan ]; then
            echo "Using existing plan file..."
            terraform apply -auto-approve tfplan
          else
            echo "No plan file found, running apply with tfvars..."
            terraform apply -auto-approve -var-file=tfvars/${{ needs.determine-environment.outputs.tfvars-file }}
          fi

      - name: Get outputs
        id: outputs
        run: |
          terraform output -json > outputs.json
          
          ALB_ENDPOINTS=$(terraform output -json alb_endpoints 2>/dev/null || echo '{}')
          if [ "$ALB_ENDPOINTS" != "{}" ]; then
            FIRST_ALB_URL=$(echo $ALB_ENDPOINTS | jq -r 'to_entries | .[0].value // empty')
            if [ -n "$FIRST_ALB_URL" ]; then
              echo "alb_url=http://$FIRST_ALB_URL" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Upload outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ needs.determine-environment.outputs.environment }}
          path: outputs.json
          retention-days: 30

      - name: Set deploy success output
        id: apply-result
        run: echo "success=true" >> $GITHUB_OUTPUT

  destroy-approval:
    name: Destroy Approval Required
    runs-on: ubuntu-latest
    needs: [setup-backends, determine-environment]
    if: |
      always() && 
      github.event_name == 'workflow_dispatch' && 
      github.event.inputs.action == 'destroy' &&
      (needs.setup-backends.result == 'success' || needs.setup-backends.result == 'skipped')
    environment: 
      name: destroy-${{ needs.determine-environment.outputs.environment }}
    outputs:
      approved: ${{ steps.approval.outputs.approved }}
    steps:
      - name: Destroy Approval Required
        id: approval
        run: |
          echo "## âš ï¸ DESTROY CONFIRMATION REQUIRED" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Action:** DESTROY ALL INFRASTRUCTURE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âš ï¸ WARNING" >> $GITHUB_STEP_SUMMARY
          echo "This will **PERMANENTLY DELETE** all infrastructure in the ${{ needs.determine-environment.outputs.environment }} environment!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” What will be destroyed:" >> $GITHUB_STEP_SUMMARY
          echo "- All EC2 instances" >> $GITHUB_STEP_SUMMARY
          echo "- All Load Balancers" >> $GITHUB_STEP_SUMMARY
          echo "- All associated resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… To proceed with destroy:" >> $GITHUB_STEP_SUMMARY
          echo "1. This step requires manual approval in GitHub" >> $GITHUB_STEP_SUMMARY
          echo "2. Go to Repository Settings â†’ Environments" >> $GITHUB_STEP_SUMMARY
          echo "3. Create environment: destroy-${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "4. Add required reviewers (yourself)" >> $GITHUB_STEP_SUMMARY
          echo "5. Then approve this deployment to proceed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**This action cannot be undone!**" >> $GITHUB_STEP_SUMMARY
          echo "approved=true" >> $GITHUB_OUTPUT

  terraform-destroy:
    name: Terraform Destroy - ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [setup-backends, determine-environment, destroy-approval]
    if: |
      always() && 
      needs.destroy-approval.outputs.approved == 'true' &&
      github.event_name == 'workflow_dispatch' && 
      github.event.inputs.action == 'destroy'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Configure Git Authentication
        run: |
          git config --global url."https://${{ secrets.PRIVATE_REPO_TOKEN }}@github.com/".insteadOf "https://github.com/"
          git config --global credential.helper store
          git config --global user.email "github-actions@github.com"
          git config --global user.name "GitHub Actions"
          
          mkdir -p ~/.git
          echo "https://${{ secrets.PRIVATE_REPO_TOKEN }}@github.com" > ~/.git-credentials
          chmod 600 ~/.git-credentials
          
          echo "GIT_CONFIG_GLOBAL=$HOME/.gitconfig" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Download backend artifacts
        if: needs.setup-backends.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: terraform-backends
          path: shared/
        continue-on-error: true

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_DEFAULT_REGION }}

      - name: Assume target account role
        run: |
          TARGET_ACCOUNT_ID=$(jq -r ".${{ needs.determine-environment.outputs.environment }}.account_id" config/aws-accounts.json)
          TARGET_ROLE_ARN="arn:aws:iam::${TARGET_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
          
          TARGET_CREDENTIALS=$(aws sts assume-role \
            --role-arn $TARGET_ROLE_ARN \
            --role-session-name github-actions-destroy-${{ needs.determine-environment.outputs.environment }}-${{ github.run_id }} \
            --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
            --output text)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $TARGET_CREDENTIALS | cut -d' ' -f1)" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $TARGET_CREDENTIALS | cut -d' ' -f2)" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $TARGET_CREDENTIALS | cut -d' ' -f3)" >> $GITHUB_ENV

      - name: Check backend configuration
        run: |
          BACKEND_FILE="shared/backend-${{ needs.determine-environment.outputs.environment }}.hcl"
          if [ ! -f "$BACKEND_FILE" ]; then
            echo "âŒ Backend configuration file not found: $BACKEND_FILE"
            echo "Available backend files:"
            ls -la shared/backend-*.hcl 2>/dev/null || echo "No backend files found"
            exit 1
          fi
          
          if grep -q "REPLACE_WITH_ACTUAL" "$BACKEND_FILE"; then
            echo "âŒ Backend configuration contains placeholder values"
            echo "Content of $BACKEND_FILE:"
            cat "$BACKEND_FILE"
            echo "Please run setup first or use an existing backend configuration."
            exit 1
          fi
          
          echo "âœ… Backend configuration looks good:"
          cat "$BACKEND_FILE"

      - name: Terraform Init
        run: |
          terraform init -backend-config=shared/backend-${{ needs.determine-environment.outputs.environment }}.hcl
        env:
          GITHUB_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}
          GIT_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Terraform Workspace
        run: |
          terraform workspace select ${{ needs.determine-environment.outputs.environment }}

      - name: Confirm Destroy Action
        run: |
          echo "ðŸš¨ DESTROY ACTION CONFIRMED"
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Tfvars file: ${{ needs.determine-environment.outputs.tfvars-file }}"
          echo "This will destroy ALL resources in the ${{ needs.determine-environment.outputs.environment }} environment!"

      - name: Terraform Destroy
        run: |
          if [ ! -f tfvars/${{ needs.determine-environment.outputs.tfvars-file }} ]; then
            echo "Error: tfvars file not found: tfvars/${{ needs.determine-environment.outputs.tfvars-file }}"
            exit 1
          fi
          
          echo "ðŸ—‘ï¸ Starting terraform destroy..."
          terraform destroy -auto-approve -var-file=tfvars/${{ needs.determine-environment.outputs.tfvars-file }}
          echo "âœ… Terraform destroy completed successfully"

  production-approval:
    name: Production Terraform Apply Approval
    runs-on: ubuntu-latest
    needs: [determine-environment, terraform-plan]
    if: |
      always() && 
      needs.determine-environment.outputs.environment == 'production' &&
      needs.terraform-plan.outputs.plan-success == 'true' &&
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.action == 'plan-and-apply'
    environment: 
      name: production-apply-approval
    steps:
      - name: Production Apply Approval Required
        run: |
          echo "## ðŸ”’ Production Apply Approval" >> $GITHUB_STEP_SUMMARY
          echo "This step requires manual approval before applying changes to production." >> $GITHUB_STEP_SUMMARY
          echo "Please review the terraform plan and approve if the changes are correct." >> $GITHUB_STEP_SUMMARY
          echo "approved=true" >> $GITHUB_OUTPUT

  promote-infrastructure:
    name: Promote Infrastructure
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]
    if: |
      always() && 
      needs.deploy.outputs.deploy-success == 'true' &&
      (
        (github.event_name == 'workflow_dispatch' && github.event.inputs.create_promotion_pr == 'true') ||
        (github.event_name == 'push' && (github.ref_name == 'dev' || github.ref_name == 'staging'))
      ) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.action != 'destroy')
    outputs:
      promotion_created: ${{ steps.promotion.outputs.skip_promotion == 'false' }}
      source_env: ${{ steps.promotion.outputs.source_env }}
      target_env: ${{ steps.promotion.outputs.target_env }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --global user.email "github-actions@github.com"
          git config --global user.name "GitHub Actions"

      - name: Determine promotion target
        id: promotion
        run: |
          SOURCE_ENV="${{ needs.determine-environment.outputs.environment }}"
          
          case $SOURCE_ENV in
            "dev") TARGET_ENV="staging" ;;
            "staging") TARGET_ENV="production" ;;
            "production") TARGET_ENV="" ;;
            *) TARGET_ENV="" ;;
          esac
          
          echo "source_env=$SOURCE_ENV" >> $GITHUB_OUTPUT
          echo "target_env=$TARGET_ENV" >> $GITHUB_OUTPUT
          
          if [ -z "$TARGET_ENV" ]; then
            echo "No promotion target for $SOURCE_ENV environment"
            echo "skip_promotion=true" >> $GITHUB_OUTPUT
          else
            echo "Promotion: $SOURCE_ENV â†’ $TARGET_ENV"
            echo "skip_promotion=false" >> $GITHUB_OUTPUT
          fi

      - name: Create repository labels
        if: steps.promotion.outputs.skip_promotion == 'false'
        run: |
          gh label create "promotion" --description "Infrastructure promotion PR" --color "0052cc" || true
          gh label create "infrastructure" --description "Infrastructure changes" --color "1d76db" || true
          gh label create "automated" --description "Automated PR" --color "0e8a16" || true
          gh label create "dev" --description "Development environment" --color "fbca04" || true
          gh label create "staging" --description "Staging environment" --color "ff9500" || true
          gh label create "production" --description "Production environment" --color "d73a49" || true
        env:
          GH_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Create promotion PR
        if: steps.promotion.outputs.skip_promotion == 'false'
        run: |
          SOURCE_ENV="${{ steps.promotion.outputs.source_env }}"
          TARGET_ENV="${{ steps.promotion.outputs.target_env }}"
          
          PR_BODY="## ðŸš€ Infrastructure Promotion

          **Source Environment:** $SOURCE_ENV
          **Target Environment:** $TARGET_ENV
          **Source Commit:** ${{ github.sha }}
          **Workflow Run:** ${{ github.run_id }}
          **Deployment Status:** âœ… $SOURCE_ENV deployment completed successfully

          ### ðŸ“‹ What's Being Promoted

          This PR promotes infrastructure changes from $SOURCE_ENV to $TARGET_ENV.

          ### ðŸš€ Next Steps

          1. **Review** all infrastructure changes
          2. **Approve and merge** to trigger $TARGET_ENV deployment

          ---
          *This PR was created automatically after successful $SOURCE_ENV deployment.*"
          
          EXISTING_PR=$(gh pr list --base $TARGET_ENV --head $SOURCE_ENV --json number --jq '.[0].number' 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_PR" ]; then
            echo "PR already exists: #$EXISTING_PR"
            echo "Updating existing PR..."
            echo "$PR_BODY" | gh pr edit $EXISTING_PR --title "ðŸš€ Promote infrastructure: $SOURCE_ENV â†’ $TARGET_ENV" --body-file -
          else
            echo "Creating new PR..."
            echo "$PR_BODY" | gh pr create \
              --base $TARGET_ENV \
              --head $SOURCE_ENV \
              --title "ðŸš€ Promote infrastructure: $SOURCE_ENV â†’ $TARGET_ENV" \
              --body-file - \
              --label "promotion,$TARGET_ENV,infrastructure,automated"
          fi
        env:
          GH_TOKEN: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Add promotion summary
        if: steps.promotion.outputs.skip_promotion == 'false'
        run: |
          echo "## ðŸš€ Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Source Environment:** ${{ steps.promotion.outputs.source_env }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target Environment:** ${{ steps.promotion.outputs.target_env }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Status:** Promotion PR created successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“‹ **Next Step:** Review and merge the PR to deploy to ${{ steps.promotion.outputs.target_env }}" >> $GITHUB_STEP_SUMMARY

      - name: No promotion needed
        if: steps.promotion.outputs.skip_promotion == 'true'
        run: |
          echo "## â„¹ï¸ No Promotion Available" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ steps.promotion.outputs.source_env }}" >> $GITHUB_STEP_SUMMARY
          echo "**Reason:** This is the final environment in the promotion chain" >> $GITHUB_STEP_SUMMARY

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy, promote-infrastructure]
    if: always()
    steps:
      - name: Generate workflow summary
        run: |
          echo "## ðŸš€ Terraform Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "âœ… **Deploy Status:** Successful" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Deploy Status:** Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.promote-infrastructure.result }}" = "success" ]; then
            echo "âœ… **Promotion Status:** Successful" >> $GITHUB_STEP_SUMMARY
            if [ "${{ needs.promote-infrastructure.outputs.promotion_created }}" = "true" ]; then
              echo "ðŸ“‹ **Next Step:** Review and merge PR: ${{ needs.promote-infrastructure.outputs.source_env }} â†’ ${{ needs.promote-infrastructure.outputs.target_env }}" >> $GITHUB_STEP_SUMMARY
            fi
          elif [ "${{ needs.promote-infrastructure.result }}" = "skipped" ]; then
            echo "â­ï¸ **Promotion Status:** Skipped" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Promotion Status:** Failed" >> $GITHUB_STEP_SUMMARY
          fi